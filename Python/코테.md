# List, 배열

```py
# list 선언
arr = [1, 2, 3, 4]

# 맨 뒤의 값 pop
arr.pop() # 1 2 3

# 맨 뒤에 값 추가
arr.append(7) # 1 2 3 7

# arr 전체 삭제, del arr[:]와 같다.
arr.clear() #
arr.append(9) # 9
arr.append(5) # 9 5
arr.append(7) # 9 5 7

# index 0에 1 삽입
arr.insert(0, 1) # 1 9 5 7

# arr.append(20)과 같은 코드
arr.insert(len(arr), 20) # 1 9 5 7 20
arr.append(9)

# 특정원소 삭제 - x와 같은 첫번째 항목 삭제
arr.remove(9) # 1 5 7 20 9

# 특정 원소의 개수 카운트. 만약 인자로 없는 원소를 보내면 ValueError가 발생
arr.count(7) # 1

# 정렬
arr.sort() # 1 5 7 9 20
arr.sort(reverse=True) # 20 9 7 5 1

# 배열 뒤집기
arr.reverse() # 1 5 7 9 20

# 얕은 복사하기, arr[:]와 같다.
arr.copy() # 말 그대로 얕은 복사
```

# Stack

- 그냥 파이썬의 기본 문법인 List를 Stack처럼 사용하면 된다.

```py
# list 선언
stack = [1] # 1

# 맨 뒤에 추가
stack.push(2) # 1 2
stack.push(3) # 1 2 3

# 값 삭제
stack.pop() # pop 후 1 2만 남는다.

stack # [1 , 2]
```

# Queue

- 코테 볼 땐 deque를 써야한다.

```py
from collections import deque

# deque 선언
queue = deque(1234)
# => TypeError.
# iterable한 데이터를 받아 생성해야하는데, int 형태가 들어와서 errer 발생

queue1 = deque("1234") # deque(['1', '2', '3', '4'])
queue2 = deque(["A", "B", "C"]) # deque(["A", "B", "C"])

# 추가
queue1.append('7') # deque(['1', '2', '3' , '7'])

# 맨 앞 삭제
queue1.popleft() # deque(['2', '3', '7'])
queue1.append(['5', '6', '7']) # deque(['2', '3', '7', ['5', '6', '7']])

# 맨 뒤도 삭제 가능
queue1.pop() # deque(['2', '3', '7'])

# 큐 회전?
queue1.rotate(1) # deque(['7', '2', '3'])
queue1.rotate(-1) # deque(['2', '3', '7']), 원본배열
queue1.rotate(-2) # deque(['7', '2', '3'])
```

# Deque

- 앞뒤로 빼기
- stack + queue의 구조

```py
from collections import deque

deque = deque(["A", "B", "C", "D", "E"]) # deque(['A', 'B', 'C', 'D', 'E'])

# 값 추가
deque.append("F") # deque(['A', 'B', 'C', 'D', 'E', 'F'])

# 맨 뒤 값 삭제
deque.pop() # deque(['A', 'B', 'C', 'D', 'E'])
deque.pop() # deque(['A', 'B', 'C', 'D'])

# 맨 앞 값 삭제
deque.popleft() # deque(['B', 'C', 'D'])
```

# Hash

- 보통 Set이나 Dictionary (딕셔너리)를 이용해서 만든다.
- key, value쌍

## Set

- set은 중복을 제거해준다.

```py
# 기본적인 set선언
_set = set() # set()
_list = [1, 2, 3, 4, 5, 6, 1, 2, 3]
_set = set(_list) # {1, 2, 3, 4, 5, 6}

# 사실 set은 집합을 위한 자료구조이다.
# & 교집합
print(_set & {1, 2, 10, 7}) # {1, 2}

# + 합집합
print(_set + {1, 2, 7, 10}) #TypeError: unsupported operand type(s) for +: 'set' and 'set' ??

# - 차집합
print(_set - {1, 2, 10, 7}) # {3, 4, 5, 6}

# 값이 쌍이 아니라서 정렬도된다.
unordered = set([1, 8, 7, 5, 3]) # {1, 8, 7, 5, 3}
print(sorted(unordered)) # [1, 3, 5, 7, 8]
print(sorted(unordered, reverse=True)) # [8, 7, 5, 3, 1]

# 🚨🚨🚨 대소문자가 섞인 문자의 중복을 없애보자
multi_list = ["Test", "test", "tESt", "TEST", "TeSt"]
print(list(set(map(lambda x: x.lower(), multi_list)))) # ['test']
```

## Dictionary

```py
# 빈 딕셔너리 생성
dict1 = {} # {}
dict2 = dict() # {}

# 값을 넣음과 동시에 딕셔너리 생성
_dict = dict(one = 1, two = 2, three = 3)
_dict = dict{'one': 1, 'two': 2, 'three': 3}

# zip을 이용해서 쉽게 만들기
_number = ['one', 'two', 'three', 'four'];
_num = [1, 2, 3, 4];
_dict = dict(zip(_number, _num))
# {'one': 1, 'two': 2, 'three': 3, 'four': 4}

# Dict에서 key로 value값 가져오기
dict0 = {'사과': 1000, '오렌지': 1500, '복숭아': 1900}
dict0['복숭아'] # 1900
# get으로 가져올 땐, 해당 key가 없을 경우 return할 값을 정해줄 수 있다.
dict0.get('복숭아', -1) # 1900
dict0.get('포도', -1) # -1

# Dict에 값 추가 및 바꾸기
dict0['포도'] = 2300
print(dict0) # {'사과': 1000, '오렌지': 1500, '복숭아': 1900, '포도': 2300}
dict0['사과'] += 200
print(dict0) # {'사과': 1200, '오렌지': 1500, '복숭아': 1900, '포도': 2300}

# Dict에서 특정 key값 삭제하기
del dict0['복숭아']
print(dict0) # {'사과': 1200, '오렌지': 1500, '포도': 2300}
del dict0['참외'] # keyError 발생 🚨

# key 순회
for key in dict0:
  print(key)

# key-value 순회
for key, value in dict0.items():
  print(f'{key}, {value}')
  '''
  사과, 1200
  오렌지, 1500
  포도, 2300
  '''

# 특정 key가 Dictionary안에 있는지 조회
print('사과' in dict0) # True
print('사과' not in dict0) # False
print('복숭아' in dict0) # False

# key만 추출
dict0.keys()

# value만 추출
dict0.values()

# key-value 둘다 추출
dict0.items()

# 정렬
dict0 = {'포도': 2300, '사과': 1800, '오렌지': 1500}
print(sorted(dict0.items())) # [('사과', 1800), ('오렌지', 1500), ('포도', 2300)]
print(sorted(dict0.keys())) # ['사과', '오렌지', '포도']
print(sorted(dict0.values())) # [1500, 1800, 2300]
```

# Tree

## Heap

- 완전 이진 트리의 일종으로, **부모의 값이 항상 자식보다 크거나 작아야** 한다.
- 항상 루트가 최댓값, 최솟값이므로 O(1)만에 찾을 수 있다. => 최대힙, 최소힙
- 🚨**파이썬의 `heapq`는 최소힙으로 동작한다.** 🚨

```py
import heapq # heapq를 사용하기 위해 import한다.

# heapq는 리스트 기반의 자료구조로, 리스트에 heapify를 사용해 이용한다.
_list = [32, 16, 54, 94, 81, 31]
heapq.heapify(_list) # _list를 heap처럼 사용한다는 뜻

# heappush(): heap에 값 넣기
heapq.heappush(_list, 100) # heap에 100을 넣었지만

# heappop(): heap에 있는 값 중 최솟값 빼기
print(heapq.heappop(_list)) # 16이 출력된다.

# heappushpop(): push하고 pop하기
print(heapq.heappushpop(_list, 99)) # 99를 넣었지만 31(최솟값)이 출력된다.
print(_list) # 실제로 _list에서 연산이 이루어지고 있다.

# nsmallest(n개, list명): list내에서 최솟값 n개 리턴
small_elements = heapq.nsmallest(4, _list) # [32, 54, 81, 94]

# nlargest(n개, list명): list내에서 최댓값 n개 리턴
large_elements = heapq.nlargest(3, _list)
print(sorted(large_elements, reverse=True)) # [100, 99, 94]

```

- 🚨 최대힙 문제는 어떻게 풀어야할까?
  - 각각의 원소에 -를 붙여서 계산한 뒤, 나중에 -를 떼주면 된다.

```py
import heapq

_list = [32, 16, 54, 94, 81, 31]
_list = list(map(lambda x: x * -1, _list)) # -1을 곱해서 대소 관계를 뒤집어준다.
heapq.heapify(_list)

print(heapq.heappop(_list) * (-1)) #94
```

# Brute-force

## Back-tracking

- 백트래킹은 조건 설정이 중요하다.

### 조합

- 조건
  - 수열 내부에 중복이 있으면 안됨
  - 수열 크기는 M이어야함
- 재귀함수 설계
  - 수를 넣으려 할 때, 이미 수열 내에 있으면 skip
  - 수열 크기가 M이 되면 return

```py
def combination():
    if len(_list) == M:
        print(*_list)
        return
    for i in range(1, N+1):
        # JS에서는 visited를 따로 만들어 방문여부를 체크한다.
        # python에서는 그냥 해당 리스트 안에 있는지 없는지 검사해서 쓰면 된다.
        if i not in _list:
            _list.append(i) # 방문 시 _list에 붙여주고
            combination()
            _list.pop(i) # 백트래킹 시 _list에서 떼어낸다.
```
