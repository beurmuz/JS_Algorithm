# List, 배열

```py
# list 선언
arr = [1, 2, 3, 4]

# 맨 뒤의 값 pop
arr.pop() # 1 2 3

# 맨 뒤에 값 추가
arr.append(7) # 1 2 3 7

# arr 전체 삭제, del arr[:]와 같다.
arr.clear() #
arr.append(9) # 9
arr.append(5) # 9 5
arr.append(7) # 9 5 7

# index 0에 1 삽입
arr.insert(0, 1) # 1 9 5 7

# arr.append(20)과 같은 코드
arr.insert(len(arr), 20) # 1 9 5 7 20
arr.append(9)

# 특정원소 삭제 - x와 같은 첫번째 항목 삭제
arr.remove(9) # 1 5 7 20 9

# 특정 원소의 개수 카운트. 만약 인자로 없는 원소를 보내면 ValueError가 발생
arr.count(7) # 1

# 정렬
arr.sort() # 1 5 7 9 20
arr.sort(reverse=True) # 20 9 7 5 1

# 배열 뒤집기
arr.reverse() # 1 5 7 9 20

# 얕은 복사하기, arr[:]와 같다.
arr.copy() # 말 그대로 얕은 복사
```

# Stack

- 그냥 파이썬의 기본 문법인 List를 Stack처럼 사용하면 된다.

```py
# list 선언
stack = [1] # 1

# 맨 뒤에 추가
stack.push(2) # 1 2
stack.push(3) # 1 2 3

# 값 삭제
stack.pop() # pop 후 1 2만 남는다.

stack # [1 , 2]
```

# Queue

- 코테 볼 땐 deque를 써야한다.

```py
from collections import deque

# deque 선언
queue = deque(1234)
# => TypeError.
# iterable한 데이터를 받아 생성해야하는데, int 형태가 들어와서 errer 발생

queue1 = deque("1234") # deque(['1', '2', '3', '4'])
queue2 = deque(["A", "B", "C"]) # deque(["A", "B", "C"])

# 추가
queue1.append('7') # deque(['1', '2', '3' , '7'])

# 맨 앞 삭제
queue1.popleft() # deque(['2', '3', '7'])
queue1.append(['5', '6', '7']) # deque(['2', '3', '7', ['5', '6', '7']])

# 맨 뒤도 삭제 가능
queue1.pop() # deque(['2', '3', '7'])

# 큐 회전?
queue1.rotate(1) # deque(['7', '2', '3'])
queue1.rotate(-1) # deque(['2', '3', '7']), 원본배열
queue1.rotate(-2) # deque(['7', '2', '3'])
```

# Deque

- 앞뒤로 빼기
- stack + queue의 구조

```py
from collections import deque

deque = deque(["A", "B", "C", "D", "E"]) # deque(['A', 'B', 'C', 'D', 'E'])

# 값 추가
deque.append("F") # deque(['A', 'B', 'C', 'D', 'E', 'F'])

# 맨 뒤 값 삭제
deque.pop() # deque(['A', 'B', 'C', 'D', 'E'])
deque.pop() # deque(['A', 'B', 'C', 'D'])

# 맨 앞 값 삭제
deque.popleft() # deque(['B', 'C', 'D'])
```

# Hash

- 보통 Set이나 Dictionary (딕셔너리)를 이용해서 만든다.
- key, value쌍

## Set

- set은 중복을 제거해준다.

```py
# 기본적인 set선언
_set = set() # set()
_list = [1, 2, 3, 4, 5, 6, 1, 2, 3]
_set = set(_list) # {1, 2, 3, 4, 5, 6}

# 사실 set은 집합을 위한 자료구조이다.
# & 교집합
print(_set & {1, 2, 10, 7}) # {1, 2}

# + 합집합
print(_set + {1, 2, 7, 10}) #TypeError: unsupported operand type(s) for +: 'set' and 'set' ??

# - 차집합
print(_set - {1, 2, 10, 7}) # {3, 4, 5, 6}

# 값이 쌍이 아니라서 정렬도된다.
unordered = set([1, 8, 7, 5, 3]) # {1, 8, 7, 5, 3}
print(sorted(unordered)) # [1, 3, 5, 7, 8]
print(sorted(unordered, reverse=True)) # [8, 7, 5, 3, 1]

# 🚨🚨🚨 대소문자가 섞인 문자의 중복을 없애보자
multi_list = ["Test", "test", "tESt", "TEST", "TeSt"]
print(list(set(map(lambda x: x.lower(), multi_list)))) # ['test']
```

## Dictionary

```py
# 빈 딕셔너리 생성
dict1 = {} # {}
dict2 = dict() # {}

# 값을 넣음과 동시에 딕셔너리 생성
_dict = dict(one = 1, two = 2, three = 3)
_dict = dict{'one': 1, 'two': 2, 'three': 3}

# zip을 이용해서 쉽게 만들기
_number = ['one', 'two', 'three', 'four'];
_num = [1, 2, 3, 4];
_dict = dict(zip(_number, _num))
# {'one': 1, 'two': 2, 'three': 3, 'four': 4}

# Dict에서 key로 value값 가져오기
dict0 = {'사과': 1000, '오렌지': 1500, '복숭아': 1900}
dict0['복숭아'] # 1900
# get으로 가져올 땐, 해당 key가 없을 경우 return할 값을 정해줄 수 있다.
dict0.get('복숭아', -1) # 1900
dict0.get('포도', -1) # -1

# Dict에 값 추가 및 바꾸기
dict0['포도'] = 2300
print(dict0) # {'사과': 1000, '오렌지': 1500, '복숭아': 1900, '포도': 2300}
dict0['사과'] += 200
print(dict0) # {'사과': 1200, '오렌지': 1500, '복숭아': 1900, '포도': 2300}

# Dict에서 특정 key값 삭제하기
del dict0['복숭아']
print(dict0) # {'사과': 1200, '오렌지': 1500, '포도': 2300}
del dict0['참외'] # keyError 발생 🚨

# key 순회
for key in dict0:
  print(key)

# key-value 순회
for key, value in dict0.items():
  print(f'{key}, {value}')
  '''
  사과, 1200
  오렌지, 1500
  포도, 2300
  '''

# 특정 key가 Dictionary안에 있는지 조회
print('사과' in dict0) # True
print('사과' not in dict0) # False
print('복숭아' in dict0) # False

# key만 추출
dict0.keys()

# value만 추출
dict0.values()

# key-value 둘다 추출
dict0.items()

# 정렬
dict0 = {'포도': 2300, '사과': 1800, '오렌지': 1500}
print(sorted(dict0.items())) # [('사과', 1800), ('오렌지', 1500), ('포도', 2300)]
print(sorted(dict0.keys())) # ['사과', '오렌지', '포도']
print(sorted(dict0.values())) # [1500, 1800, 2300]
```
