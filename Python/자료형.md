# 1. 자료형

- 파이썬은 기본, 사전, 집합 자료형 등 여러 가지의 자료형을 기본으로 내장하고 있다.

## 1. 수 자료형

### 1. 1 정수형 (Integer)

- 정수를 다루는 자료형
  - 양의 정수, 0, 음의 정수

```py
a = 100 # 양의 정수
print(a) # 100

b = -1 # 음의 정수
print(b) # -1

c = 0 # 0
print(c) # 0
```

### 1. 2 실수형 (Real Number)

- 소수점 아래의 데이터를 포함하는 수 자료형
  - 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리한다.
- 소수부나 정수부가 0인 경우 0을 생략하고 작성할 수 있다.
- 지수 표현 방식도 사용할 수 있다.
  - `유효숫자e^지수 = 유효숫자 * 10^지수`
  - ex) 2e5 => 2 \* 10^5
  - 최단 경로 문제에서 도달할 수 없는 노드에 대해 최단 거리를 '무한(INF)'로 설정하곤 한다.
- 사실 컴퓨터는 실수를 정확히 표현하지 못한다.

```py
a = 156.5 # 양의 실수
print(a) # 156.5

b = -1.7 # 음의 실수
print(b) # -1.7

c = 156. # 소수부가 0일때 0을 생략
print(c) # 156.0

d = -.99 # 정수부가 0일 때 0을 생략
print(d) # -0.99

e = 1e9 # 10억의 지수 표현 방식
print(e) # 1000000000.0

f = 72.52e1
print(f) # 725.2

g = 3245e-3
print(g) # 3.245
```

- 소수점을 계산할 때에는 `round()`함수를 이용하자.
  - `round(실수형 데이터, 반올림하고자 하는 위치 -1)`
  - 두번째 인자가 없으면 무조건 소수점 첫번째 자리에서 반올림한다.
  - ex) round(123.456, 2) => 123.46

```py
a = 0.3 + 0.6
print(a) # 0.9가 나올 것 같지만 놀랍게도 0.8999999999999999 가 출력된다.

a = round(a, 4)
print(a) # 0.9

if round(a, 4) == 0.9:
    print(True)
else:
    print(False)

# True가 결과로 나온다.
```

### 1. 3 수 자료형 연산

- 다른 프로그래밍 언어처럼 사칙연산을 쓸 수 있는데 유의할 사항이 있다.
  - 🚨 `/` : 결과가 실수형으로 나온다.
  - 🚨 `%` : 나머지 값을 알 수 있다.
  - 🚨 `//` : 나눈 결과에서 몫만 알 수 있다.
- `**` : 거듭제곱 연산자

```py
a = 5
b = 2

print(a / b) # 2.5 (실수형태로 결과 값이 출력됨)
print(a % b) # 1 (나머지)
print(a // b) # 2 (몫)
print(a ** b) # a^b, 즉 5^2 이므로 25
```

## 2. 리스트 자료형

- 다른 언어로 치자면 '배열(array)' or '테이블(table)'

### 2. 1 리스트 생성 및 초기화

- 인덱스는 0부터 시작한다.
- 비어있는 리스트 선언 시 `list()`나 `[]`를 이용하면 된다.

```py
a = [1, 2, 3, 4, 5, 6, 7]
print(a) # [1, 2, 3, 4, 5, 6, 7]

# 인덱스로 리스트에 접근하기, 인덱스는 0부터 시작함
print(a[4]) # 5

# 빈 리스트 선언하기 1
b = list()
print(b) # []

# 빈 리스트 선언하기 2
c = []
print(c) # []

# 🚨 크기가 n인 1차원 리스트 초기화 하는 법
n = 9
d = [0] * n
print(d) # [0, 0, 0, 0, 0, 0, 0, 0, 0]
```

### 2. 2 리스트의 인덱싱, 슬라이싱

- 인덱싱(indexing): 인덱스 값으로 리스트의 특정 원소에 접근하는 것
  - 양의 정수로 접근 시 앞에서부터 탐색하고,
  - 음의 정수로 접근 시 거꾸로 (뒤부터) 탐색한다.

```py
a = [1, 2, 3, 4, 5, 6, 7]

# 뒤에서 두번째 원소 출력
print(a[-2]) # 6

# 네번째 원소 값 변경
a[3] = 10
print(a) # [1, 2, 3, 10, 5, 6, 7]
```

- 슬라이싱(Slicing)
  - 대괄호 안에 `:`을 넣어 시작 인덱스를 설정할 수 있다.
  - 🚨 **단, 항상 끝 인덱스에서 -1한 곳까지 값이 출력된다.**

```py
a = [1, 2, 3, 4, 5, 6, 7]
# index가 1인 곳부터 5-1인 곳까지
print(a[1:5]) # 2, 3, 4, 5
```

### 2. 3 리스트 컴프리헨션 (= 리스트 초기화 방법)

- 리스트를 초기화하는 방법 중 하나
  - 대괄호 ([])안에 조건문, 반복문을 넣는 방식으로 리스트 초기화가 가능하다.
  - 리스트 컴프리헨션을 이용하면 간결하게 코드를 작성할 수 있다.

```py
# 0부터 10까지의 수 중 짝수만 포함하는 리스트
arr = [i for i in range(11) if i % 2 == 0]
# range에는 항상 원하는 값 +1을 해주어야 한다.
print(arr) # [0, 2, 4, 6, 8, 10]

# 사실 위의 코드는 다음과 같은 코드이다.
arr = []
for i in range(11):
  if i % 2 == 0:
    arr.append(i)
print(arr) # [0, 2, 4, 6, 8, 10]

# 1부터 10까지 제곱한 값으로 초기화한 리스트
arr2 = [i * i for i in range(1, 11)]
print(arr2) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# 🚨 n x m의 2차원 리스트 초기화 시 쓰는 방법 🚨
n = 3
m = 4
nmarr = [[0] * m for _ in range(n)]
print(nmarr) # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
```

### 2. 4 리스트 관련 메서드들

| 메서드명  | 사용법                                         | 설명                                                              | 시간 복잡도 |
| :-------- | :--------------------------------------------- | :---------------------------------------------------------------- | :---------: |
| append()  | 변수명.append()                                | 리스트에 원소 하나 삽입 시 사용                                   |    O(1)     |
| sort()    | 변수명.sort()                                  | 기본 정렬기능. 오름차순 정렬                                      |  O(nlogn)   |
|           | 변수명.sort(reverse = True)                    | 내림차순 정렬                                                     |  O(nlogn)   |
| reverse() | 변수명.reverse()                               | 리스트 원소의 순서 뒤집기                                         |    O(n)     |
| insert()  | 변수명.insert(삽입할 위치의 인덱스, 삽입할 값) | 특정 인덱스 위치에 원소 삽입 시 사용                              |    O(n)     |
| count()   | 변수명.count(특정 값)                          | 리스트에서 특정 값을 가지는 데이터 개수를 셀 때 사용              |    O(n)     |
| remove()  | 변수명.remove(특정 값)                         | 특정 값을 갖는 원소 제거 시 사용. (여러 개가 있어도 1개만 제거함) |    O(n)     |

```py
a = [1, 3, 7, 5]
print('기본: ', a) # [1, 3, 7, 5]

# 리스트에 원소 삽입
a.append(2)
print('원소 삽입: ', a) # [1, 3, 7, 5, 2]

# 오름차순
a.sort()
print('오름차순 정렬: ', a) # [1, 2, 3, 5, 7]

# 내림차순
a.sort(reverse = True)
print('내림차순 정렬: ', a) # [7, 5, 3, 2, 1]

# 리스트 원소 뒤집기
a.reverse()
print('원소 뒤집기: ', a) # [1, 2, 3, 5, 7]

# 특정 인덱스에 데이터 추가
a.insert(2, 7) # 인덱스2 자리에 7 추가. 인덱스2에 있던 기존 값은 뒤로 밀림
print('특정 인덱스에 값 추가: ', a) # [1, 2, 7, 3, 5, 7]

# 특정 값의 개수 세기
print('7의 개수: ', a.count(7)) # 2

# 특정 값 데이터 삭제
a.remove(7) # 7은 2개 있지만, remove로 7을 지워도 가장 앞에 있는 한개만 지워짐
print('7 삭제 시: ', a) # [1, 2, 3, 5, 7]
```

- 그렇다면 어떻게해야 리스트에서 특정 값의 원소를 전부 제거할 수 있을까?
  - 보통 변수와 포함 여부를 이용해 풀어야 한다.

```py
a = [1, 2, 3, 4 , 5, 7, 7]
remove_set = { 2, 7 }

# remove_set에 없는 값만 저장
result = [i for i in a if i not in remove_set] # 1과 7을 전부 재어함
print(result) # [1, 3, 4, 5]
```

## 3. 문자열 자료형

- 변수에 큰따옴표나 작은 따옴표를 이용해 문자열을 저장한다.
- `+`를 이용해 문자열을 연결하고, `*`를 이용해 문자열을 반복할 수 있다.

```py
stringData = 'I gonna \"pass\".'
print(stringData) # I gonna "pass".

# 문자열 연결
a = 'I have to study hard to do that.'
print(stringData + ' ' + a) # I gonna "pass". I have to study to do that.

# 문자열 반복
print(stringData*3) # I gonna "pass".I gonna "pass".I gonna "pass".

# 문자열에서 pass만 추출하기 - 인덱스와 슬라이싱 사용하기
# 시작지점 ~ 끝 + 1 지점
print(stringData[9 : 13]) # pass
```

## 4. 튜플 자료형

- 리스트와 비슷한 듯 다르다.
  1. 🚨 튜플은 한 번 선언된 값을 변경할 수 없다.
  2. 🚨 리스트는 대괄호 (`[]`)를, 튜플은 소괄호 (`()`)를 사용한다.
- 그래프 알고리즘을 구현할 때 자주 사용된다.
  - 한번 들어간 값은 절대 변경되지 않는 우선순위 큐 구현시 자주 사용한다.
  - 다익스트라 최단 경로 알고리즘에서는 (비용, 노드번호) 형태로 튜플로 묶어 관리한다.
- 리스트에 비해 상대적으로 공간 효율적이다.

```py
a = (1, 2, 3, 4)
print(a) # (1, 2, 3, 4)

# 대입연산자로 원소 값을 바꿀 수 없음
a[2] = 7 # error 발생
```

## 5. 사전 자료형

- key와 value 쌍을 데이터로 가지는 자료형
  - 리스트나 튜플은 값을 순차적으로 저장하며 인덱싱이 가능하나
  - 사전 자료형은 인덱싱을 활용할 수 없다.
- 내부적으로 **해시 테이블**을 이용하므로 기본적으로 데이터 검색, 수정에 있어 O(1) 시간이 걸린다.
  - 즉, 리스트보다 빠르게 찾을 수 있다는 말이다.

```py
data = dict()
data['빨간색'] = 'red'
data['노란색'] = 'yellow'
data['주황색'] = 'orange'

print(data) # {'빨간색': 'red', '노란색': 'yellow', '주황색': 'orange'}

# 사전 자료형에 특정 원소가 있는지 검사할 때
if '빨간색' in data:
  print('빨간색은 data안에 있습니다.')

# 사전 자료형 key만 뽑아내기
keyList = data.keys()
print(keyList) # dict_keys(['빨간색', '노란색', '주황색'])

# 사전 자료형 value만 뽑아내기
valueList = data.values()
print(valueList) # dict_values(['red', 'yellow', 'orange'])

# 각 키에 따른 value 출력 방법
for key in keyList:
  print(data[key])
# red
# yellow
# orange
```

## 6. 집합 자료형

- 집합을 처리하기 위한 자료형
- 리스트나 문자열을 이용해 만들 수 있다.
- 집합 자료형만의 특징이 있다.
  1. 중복을 허용하지 X
  2. 순서가 X - 사전, 집합 자료형은 순서가 없어 인덱싱이 불가능하다.
- 집합 자료형은 키가 없고 값만 가지고 있다.
- 특정 원소의 존재 여부는 O(1)만에 알 수 있다.
- `set()`함수나 `{}`로 초기화한다.

```py
data = set([1, 2, 3, 3, 3, 4, 5])
print(data) # {1, 2, 3, 4, 5}

data = {1, 2, 3, 3, 3, 4, 5}
print(data) # {1, 2, 3, 4, 5}
```

- 합집합, 교집합, 차집합 연산이 가능하다.
- 원소 추가 및 삭제가 가능하다.

```py
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

print('합집합', a | b) # 합집합 {1, 2, 3, 4, 5, 6, 7}
print('교집합', a & b) # 교집합 {3, 4, 5}
print('차집합', a - b) # 차집합 {1, 2}

# 새로운 원소 추가하기
c = set([1, 2, 3])
c.add(4)
print(c) # {1, 2, 3, 4}

# 여러개의 원소 추가하기
c.update([5, 6, 7])
print(c) # {1, 2, 3, 4, 5, 6, 7}

# 특정 값 삭제하기
c.remove(3)
print(c) # {1, 2, 4, 5, 6, 7}
```
